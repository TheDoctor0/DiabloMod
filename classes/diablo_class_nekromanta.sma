/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <fakemeta>
#include <fakemeta_util>
#include <cstrike>
#include <fun>
#include <engine>
#include <ColorChat>

#include <diablo_nowe.inc>

#define pev_zorigin	pev_fuser4
#define seconds(%1) ((1<<12) * (%1))

#define TASKID_MODEL 9387
#define TASKID_RESPAWN 4563
#define TASKID_CHECKRE 1231
#define TASKID_ORIGIN 12312
#define TASKID_CHECKST 125435
#define TASKID_SETUSER 2314
#define TASKID_GODMODE 7314
#define TASKID_REVIVE 8921

new NEKRO_VIEW[]       = "models/diablomod/v_nekromanta.mdl"

#define PLUGIN "Nekromanta"
#define VERSION "1.0"
#define AUTHOR "O'Zone"

new SOUND_START[] 	= "items/medshot4.wav"
new SOUND_FINISHED[] 	= "items/smallmedkit2.wav"
new SOUND_FAILED[] 	= "items/medshotno1.wav"

new CT_Skins[4][] = {"sas","gsg9","urban","gign"};
new Terro_Skins[4][] = {"arctic","leet","guerilla","terror"};

new pCvarRevival,pCvarDistance,pCvarRevivalHealth;
new Float:g_revive_delay[33]
new Float:g_body_origin[33][3]

new bool:bKlasa[33];

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	diablo_register_class("Nekromanta",115,"<br>Na starcie posiada: 115HP.<br>Moze wskrzeszac umarlych i bezczescic zwloki przeciwnikow (przytrzymaj E stojac obok ciala).<br>Kazda bronia zadaje +8 obrazen.<br>Umiejetnosc ladowana na nozu: Czar zmieniajacy stroj na ubranie wroga na 30s.<br><br>" )
	
	pCvarRevival 		=	register_cvar("diablo_revival_time","3");
	pCvarRevivalHealth	=	register_cvar("diablo_revival_health","50");
	pCvarDistance		=	register_cvar("diablo_revival_distance", "70.0")
}

public client_disconnect(id)
	remove_task(id + TASKID_MODEL);

public diablo_class_disabled(id){
	bKlasa[id]	=	false;
	remove_task(id + TASKID_MODEL);
}

public diablo_class_enabled(id){
	bKlasa[id]	=	true;
}

public plugin_precache(){
	precache_sound(SOUND_START);
	precache_sound(SOUND_FINISHED);
	precache_sound(SOUND_FAILED);
	precache_model(NEKRO_VIEW);
}

public diablo_weapon_deploy(id,wpnID,weaponEnt){
	if(bKlasa[id] && wpnID == CSW_KNIFE){
		entity_set_string(id, EV_SZ_viewmodel, NEKRO_VIEW) 
	}
}

public diablo_clean_data(id){
	g_revive_delay[id] 	= 0.0
	g_body_origin[id] 	= Float:{0.0, 0.0, 0.0}
	remove_task(id + TASKID_MODEL);
}

public diablo_set_data(id){
	g_revive_delay[id] 	= 0.0
	g_body_origin[id] 	= Float:{0.0, 0.0, 0.0}
}

public diablo_damage_class_do(iVictim,iAttacker,&Float:fDamage,damageBits){
	fDamage += 8.0;
}

public Float:diablo_cast_time(id,Float:standardTime){
	return standardTime*0.7;
}

public diablo_call_cast(id){
	set_hudmessage(60, 200, 25, -1.0, 0.25, 0, 1.0, 2.0, 0.1, 0.2, 2)
	show_hudmessage(id, "Zmieniles czarem tymczasowo swoj stroj na ubranie wroga")
	
	ZmienUbranie(id, 0);
	
	remove_task(id + TASKID_MODEL);
	set_task(30.0, "ChangeModel", id + TASKID_MODEL);
}

public ChangeModel(id){
	id -= TASKID_MODEL;
	if(is_user_connected(id)){
		ZmienUbranie(id, 1);
		set_hudmessage(60, 200, 25, -1.0, 0.25, 0, 1.0, 2.0, 0.1, 0.2, 2)
		show_hudmessage(id, "Czar zmieniajacy stroj przestal dzialac")
	}
}

public ZmienUbranie(id, reset)
{
	if(!is_user_connected(id))
		return PLUGIN_CONTINUE;

	if(reset)
		cs_reset_user_model(id);
	else
	{
		new num = random_num(0,3);
		cs_set_user_model(id, (get_user_team(id) == 1)? CT_Skins[num]: Terro_Skins[num]);
	}
	return PLUGIN_CONTINUE;
}

public diablo_class_skill_used(id){
	if(task_exists(id + TASKID_REVIVE) || !is_user_alive(id))
		return PLUGIN_CONTINUE
	
	if(!(fm_get_user_button(id) & IN_USE))
		return PLUGIN_CONTINUE
	
	new body = find_dead_body(id)
	if(!fm_is_valid_ent(body))
		return PLUGIN_CONTINUE
	
	new lucky_bastard = pev(body, pev_owner)
	new lb_team = get_user_team(lucky_bastard)
	if(lb_team != 1 && lb_team != 2)
		return PLUGIN_CONTINUE
	
	static szName[64]
	get_user_name(lucky_bastard, szName,charsmax( szName ) )
	if(get_user_team(lucky_bastard) == get_user_team(id))
		client_print(id, print_center, "Odradzanie %s", szName)
	else
		client_print(id, print_center, "Beszczeszczenie %s", szName)
		
	new revivaltime = get_pcvar_num(pCvarRevival)
	msg_bartime(id, revivaltime)
	
	new Float:gametime = get_gametime()
	g_revive_delay[id] = gametime + float(revivaltime) - 0.01
	
	emit_sound(id, CHAN_AUTO, SOUND_START, VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
	set_task(0.1, "task_revive", id + TASKID_REVIVE)
	
	return PLUGIN_CONTINUE
}

public task_revive(id)
{
	id -= TASKID_REVIVE;
	
	if(!is_user_alive(id))
	{
		failed_revive(id)
		return FMRES_IGNORED
	}
	
	if(!(fm_get_user_button(id) & IN_USE))
	{
		failed_revive(id)
		return FMRES_IGNORED
	}
	
	new body = find_dead_body(id)
	if(!fm_is_valid_ent(body))
	{
		failed_revive(id)
		return FMRES_IGNORED
	}
	
	new lucky_bastard = pev(body, pev_owner)
	if(!is_user_connected(lucky_bastard))
	{
		failed_revive(id)
		return FMRES_IGNORED
	}
	
	new lb_team = get_user_team(lucky_bastard)
	if(lb_team != 1 && lb_team != 2)
	{
		failed_revive(id)
		return FMRES_IGNORED
	}
	
	static Float:velocity[3]
	pev(id, pev_velocity, velocity)
	velocity[0] = 0.0
	velocity[1] = 0.0
	set_pev(id, pev_velocity, velocity)
	
	new Float:gametime = get_gametime()
	if(g_revive_delay[id] < gametime)
	{
		if(findemptyloc(body, 2.5))
		{
			fm_remove_entity(body)
			emit_sound(id, CHAN_AUTO, SOUND_FINISHED, VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
			
			new args[3]
			args[0]=lucky_bastard
			args[1]=id
			args[2]=0
			
			static szName[64]
			get_user_name(lucky_bastard, szName,charsmax( szName ) )
			
			if(get_user_team(id) != get_user_team(lucky_bastard))
			{
				set_user_health(id, min(get_user_health(id) + 30, diablo_get_max_hp(id)));
				ColorChat(id,GREEN,"^x04[DiabloMod]^x01 Zbeszczesciles zwloki^x03 %s^x01.^x04 +30 HP^x01!" , szName);
			}
			else
			{
				ColorChat(id,GREEN,"^x04[DiabloMod]^x01 Zreanimowales^x03 %s^x01.^x04 +25 EXP'a^x01!" , szName);
				diablo_add_xp(id,25);
				
				if(diablo_is_this_class(lucky_bastard, "Nekromanta") && diablo_is_this_class(id, "Nekromanta"))
				{
					args[2] = diablo_get_user_class(lucky_bastard);
					
					log_to_file("addons/amxmodx/logs/diablo.log", "Odrodzenie Nekromanty");
					
					diablo_set_user_class(lucky_bastard, 0);
					
					new data[2];
					data[0] = id;
					data[1] = lucky_bastard;
					set_task(0.1, "GetDistance", id, data, 2);
					set_task(0.3, "GetDistance", id, data, 2);
					set_task(0.5, "GetDistance", id, data, 2);
					set_task(1.0, "GetDistance", id, data, 2);
				}
				
				set_task(0.1, "task_respawn", TASKID_RESPAWN + lucky_bastard,args,3)
			}
			
		}
		else
			failed_revive(id)
	}
	else
		set_task(0.1, "task_revive", id + TASKID_REVIVE)
	
	return FMRES_IGNORED
}

public GetDistance(data[])
{
	log_to_file("addons/amxmodx/logs/diablo.log", "Dystans: %i unitow.", get_entity_distance(data[0], data[1]));
}

public task_respawn(args[]) 
{
	new id = args[0]
	
	if (!is_user_connected(id) || is_user_alive(id) || cs_get_user_team(id) == CS_TEAM_SPECTATOR) return
	
	if(args[2] > 0)
		diablo_set_user_class(id, args[2]);
	set_pev(id, pev_deadflag, DEAD_RESPAWNABLE) 
	dllfunc(DLLFunc_Think, id) 
	dllfunc(DLLFunc_Spawn, id) 
	set_pev(id, pev_iuser1, 0)
	
	set_task(0.1, "task_check_respawn", TASKID_CHECKRE + id,args,3)
}

public task_check_respawn(args[])
{
	new id = args[0]
	
	if(pev(id, pev_iuser1))
		set_task(0.1, "task_respawn", TASKID_RESPAWN + id,args,3)
	else
		set_task(0.1, "task_origin", TASKID_ORIGIN + id,args,3)
}

public task_origin(args[])
{
	new id = args[0]
	engfunc(EngFunc_SetOrigin, id, g_body_origin[id])
	
	static  Float:origin[3]
	pev(id, pev_origin, origin)
	set_pev(id, pev_zorigin, origin[2])
	
	set_task(0.1, "task_stuck_check", TASKID_CHECKST + id,args,3)
	
}
public task_stuck_check(args[])
{
	new id = args[0]

	static Float:origin[3]
	pev(id, pev_origin, origin)
	
	if(origin[2] == pev(id, pev_zorigin))
		set_task(0.1, "task_respawn", TASKID_RESPAWN + id,args,3)
	else
		set_task(0.1, "task_setplayer", TASKID_SETUSER + id,args,3)
}

public task_setplayer(args[])
{
	new id = args[0]
	
	fm_give_item(id, "weapon_knife")
	
	diablo_add_hp(id,get_pcvar_num(pCvarRevivalHealth) + diablo_get_user_int(args[1]));	
		
	Display_Fade(id,seconds(2),seconds(2),0,0,0,0,255)
	
	set_user_godmode(id, 1);
	
	set_task(3.0, "godmode_off", id + TASKID_GODMODE);
}

public godmode_off(id)
{
	id -= TASKID_GODMODE;
	
	if(is_user_connected(id))
		set_user_godmode(id, 0);
}

public failed_revive(id)
{
	msg_bartime(id, 0)
	emit_sound(id, CHAN_AUTO, SOUND_FAILED, VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
}

stock find_dead_body(id)
{
	static Float:origin[3]
	pev(id, pev_origin, origin)
	
	new ent
	static classname[32]	
	while((ent = fm_find_ent_in_sphere(ent, origin, get_pcvar_float(pCvarDistance))) != 0) 
	{
		pev(ent, pev_classname, classname, 31)
		if(equali(classname, "fakeCorpse") && fm_is_ent_visible(id, ent) && is_user_connected( pev( ent , pev_owner ) ) && !is_user_alive( pev( ent , pev_owner ) ))
		return ent
	}
	return 0
}

stock msg_bartime(id, seconds) 
{
	if(is_user_bot(id)||!is_user_alive(id)||!is_user_connected(id))	return
	
	if((fm_get_user_button(id) & IN_USE))	diablo_damage(id,0,10.0,diabloDamageKnife);
	
	static g_msg_bartime;
	
	if(!g_msg_bartime)	g_msg_bartime	=	get_user_msgid("BarTime")
	
	message_begin(MSG_ONE, g_msg_bartime, _, id)
	write_byte(seconds)
	write_byte(0)
	message_end()
}

stock bool:findemptyloc(ent, Float:radius)
{
	if(!fm_is_valid_ent(ent))
	return false

	static Float:origin[3]
	pev(ent, pev_origin, origin)
	origin[2] += 20.0
	
	new owner = pev(ent, pev_owner)
	new num = 0, bool:found = false
	
	while(num <= 100)
	{
		if(is_hull_vacant(origin))
		{
			g_body_origin[owner][0] = origin[0]
			g_body_origin[owner][1] = origin[1]
			g_body_origin[owner][2] = origin[2]
			
			found = true
			break
		}
		else
		{
			origin[0] += random_float(-radius, radius)
			origin[1] += random_float(-radius, radius)
			origin[2] += random_float(-radius, radius)
			
			num++
		}
	}
	return found
}

stock bool:is_hull_vacant(const Float:origin[3])
{
	new tr = 0
	engfunc(EngFunc_TraceHull, origin, origin, 0, HULL_HUMAN, 0, tr)
	if(!get_tr2(tr, TR_StartSolid) && !get_tr2(tr, TR_AllSolid) && get_tr2(tr, TR_InOpen))
	return true
	
	return false
}

stock Display_Fade(id,duration,holdtime,fadetype,red,green,blue,alpha)
{
	static g_msg_screenfade;
	
	if(!g_msg_screenfade)	g_msg_screenfade	=	get_user_msgid("ScreenFade");
	
	message_begin( MSG_ONE, g_msg_screenfade,{0,0,0},id )
	write_short( duration )	// Duration of fadeout
	write_short( holdtime )	// Hold time of color
	write_short( fadetype )	// Fade type
	write_byte ( red )		// Red
	write_byte ( green )		// Green
	write_byte ( blue )		// Blue
	write_byte ( alpha )	// Alpha
	message_end()
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1045\\ f0\\ fs16 \n\\ par }
*/
