/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta>
#include <fakemeta_util>

#include <diablo_nowe.inc>

#define PLUGIN "Paladyn"
#define VERSION "1.0"
#define AUTHOR "O'Zone"

#define PALADYN_VIEW	"models/diablomod/v_paladyn.mdl"

new bool:bKlasa[33],jumpsLeft[33],golden_bulet[33], Float:lastJump[33];

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	diablo_register_class("Paladyn",115,"<br>Na starcie posiada: 115HP.<br>Moze wykonywac tzw. Long Jump (daleki skok - przytrzymujÄ…c klawisz Ctrl + Spacja). Ma 1/8 szansy na odbicie pocisku.<br>Umiejetnosc ladowana na nozu: Magiczne pociski, ktore zawsze trafiaja w glowe przy zranieniu wroga<br><br>")
	
	register_forward(FM_TraceLine,"fw_traceline");
}

public plugin_precache(){
	precache_model(PALADYN_VIEW);
}

public diablo_class_enabled(id){
	bKlasa[id]		=	true;
	jumpsLeft[id]		=	3 + floatround(float(diablo_get_user_int(id))/10.0);
	golden_bulet[id]	=	0;
}

public diablo_class_disabled(id){
	bKlasa[id]		=	false;
	jumpsLeft[id]		=	0;
	golden_bulet[id]	=	0;
}

public diablo_set_data(id){
	jumpsLeft[id]		=	3 + floatround(float(diablo_get_user_int(id))/10.0);
	golden_bulet[id]	=	0;
}

public diablo_clean_data(id){
	jumpsLeft[id]		=	0;
	golden_bulet[id]	=	0;
}

public diablo_weapon_deploy(id,wpnID,weaponEnt){
	if(wpnID == CSW_KNIFE && jumpsLeft[id] > 0 && bKlasa[id]){
		fm_set_user_longjump(id,true,true);
	}
	else{
		fm_set_user_longjump(id,false,false);
	}
	
	if(wpnID == CSW_KNIFE && bKlasa[id]){
		entity_set_string(id, EV_SZ_viewmodel, PALADYN_VIEW) 
	}
}

public diablo_preThink(id){
	if(!is_user_alive(id) || !jumpsLeft[id] || get_user_weapon(id) != CSW_KNIFE)	
		return PLUGIN_CONTINUE;
	
	new button = get_user_button(id);
	new flags = pev(id,pev_flags);
	
	if((button & IN_DUCK) && (button & IN_JUMP) && !(get_user_oldbutton(id) & IN_JUMP) && !diablo_is_freezetime() && flags & FL_ONGROUND && get_gametime() > lastJump[id] + 3.0) 
	{ 
		if(--jumpsLeft[id] < 1)
		{
			fm_set_user_longjump(id,false,false);
			return PLUGIN_CONTINUE;
		}

		lastJump[id] = get_gametime();

		set_pev ( id, pev_flags, flags & ~FL_ONGROUND );

		new Float:va[3],Float:v[3]; 
		entity_get_vector(id,EV_VEC_v_angle,va); 
		v[0]=floatcos(va[1]/180.0*M_PI)*560.0; 
		v[1]=floatsin(va[1]/180.0*M_PI)*560.0; 
		v[2]=300.0;
		entity_set_vector(id,EV_VEC_velocity,v); 

		diablo_write_hud_native(id);
	}
	
	return PLUGIN_CONTINUE;
}

public Float:diablo_cast_time(id,Float:standardTime){
	return standardTime * 1.4
}

public diablo_call_cast(id){
	set_hudmessage(60, 200, 25, -1.0, 0.25, 0, 1.0, 2.0, 0.1, 0.2, 2)
	
	golden_bulet[id]++
	if(golden_bulet[id] > 3)
	{
		golden_bulet[id] = 3
		show_hudmessage(id, "Mozesz miec maksymalnie 3 magiczne pociski", golden_bulet[id]) 
	}
	else if(golden_bulet[id] == 1)show_hudmessage(id, "Masz 1 magiczny pocisk") 
	else if(golden_bulet[id] > 1)show_hudmessage(id, "Masz %i magiczne pociski", golden_bulet[id]) 
}

public diablo_hud_write(id,szMessage[],iLen){
	if(bKlasa[id]){
		new szTmp[64];
		if(!diablo_player_hud(id))
			formatex(szTmp, charsmax( szTmp ) ," Skoki: %i/%i", jumpsLeft[id], 3 + floatround(float(diablo_get_user_int(id))/10.0));
		else
			formatex(szTmp, charsmax( szTmp ) ,"^n[Skoki: %i/%i]", jumpsLeft[id], 3 + floatround(float(diablo_get_user_int(id))/10.0));
		
		add(szMessage,iLen,szTmp);
	}
}

public fw_traceline(Float:vecStart[3],Float:vecEnd[3],ignoreM,id,trace) // pentToSkip == id, for clarity
{
	if(!is_user_connected(id))
		return FMRES_IGNORED;

	// not a player entity, or player is dead
	if(!is_user_alive(id))
		return FMRES_IGNORED;

	new hit = get_tr2(trace, TR_pHit)	
	
	// not shooting anything
	if(!(pev(id,pev_button) & IN_ATTACK))
		return FMRES_IGNORED;
	
	if(is_user_alive(hit) && get_user_team(id) != get_user_team(hit))
	{
		if(golden_bulet[id]>0)
		{
			golden_bulet[id]--
			set_tr2(trace, TR_iHitgroup, HIT_HEAD) // Redirect shot to head
			
			// Variable angles doesn't really have a use here.
			static hit, Float:head_origin[3], Float:angles[3]
			
			hit = get_tr2(trace, TR_pHit) // Whomever was shot
			engfunc(EngFunc_GetBonePosition, hit, 8, head_origin, angles) // Find origin of head bone (8)
			
			set_tr2(trace, TR_vecEndPos, head_origin) // Blood now comes out of the head!
			
			return FMRES_IGNORED;
		}
		
		if(bKlasa[hit] && random_num(1, 8) == 1)
			set_tr2(trace, TR_iHitgroup, 8)
			
		return FMRES_IGNORED;
	}
	
	return FMRES_IGNORED;
}

stock Float:player_speed(index) 
{
	new Float:vec[3]
	
	pev(index,pev_velocity,vec)
	vec[2]=0.0
	
	return floatsqroot ( vec[0]*vec[0]+vec[1]*vec[1] )
}
